
/*PGR-GNU*****************************************************************

Copyright (c) 2018  pgRouting developers
Mail: project at pgrouting.org

------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 ********************************************************************PGR-GNU*/

BEGIN;

SELECT CASE WHEN min_version('3.6.0') THEN plan(9) ELSE plan(6) END;

/* TODO remove test1 in v4 */
SELECT
    node::BIGINT, edge::BIGINT, round(cost, 12) AS cost, round(agg_cost, 12) AS agg_cost
INTO test1
FROM
(VALUES
    (  -1 ,   -1 ,    0 ,        0),
    (   1 ,    1 ,  0.4 ,      0.4),
    (   2 ,    1 ,  0.6 ,      0.6),
    (   5 ,    4 ,    1 ,      1.6),
    (   6 ,    8 ,    1 ,      2.6),
    (   8 ,    7 ,    1 ,      2.6),
    (  10 ,   10 ,    1 ,      2.6),
    (   7 ,    6 ,    1 ,      3.6),
    (   9 ,    9 ,    1 ,      3.6),
    (  11 ,   11 ,    1 ,      3.6),
    (  13 ,   14 ,    1 ,      3.6),
    (   4 ,   16 ,    1 ,      4.6),
    (  12 ,   13 ,    1 ,      4.6),
    (   3 ,    3 ,    1 ,      5.6)
) AS t (node, edge, cost, agg_cost);

SELECT
    node::BIGINT, edge::BIGINT, cost::FLOAT, agg_cost::FLOAT
INTO test2
FROM
(VALUES
    (  -1 ,   -1 ,    0 ,        0),
    (   1 ,    1 ,  0.4 ,      0.4),
    (   2 ,    1 ,    1 ,      1.4),
    (   5 ,    4 ,    1 ,      2.4),
    (   6 ,    8 ,    1 ,      3.4),
    (   8 ,    7 ,    1 ,      3.4),
    (  10 ,   10 ,    1 ,      3.4),
    (   7 ,    6 ,    1 ,      4.4),
    (   9 ,    9 ,    1 ,      4.4),
    (  11 ,   11 ,    1 ,      4.4),
    (  13 ,   14 ,    1 ,      4.4),
    (   4 ,   16 ,    1 ,      5.4),
    (  12 ,   13 ,    1 ,      5.4),
    (   3 ,    3 ,    1 ,      6.4)
) AS t (node, edge, cost, agg_cost);

SELECT
    node::BIGINT, edge::BIGINT, cost::FLOAT, agg_cost::FLOAT
INTO test3
FROM
(VALUES
   (-1 ,   -1 ,    0 ,        0),
   ( 2 ,    1 ,  0.6 ,      0.6),
   ( 5 ,    4 ,    1 ,      1.6),
   ( 1 ,    1 ,    1 ,      1.6),
   ( 6 ,    8 ,    1 ,      2.6),
   ( 8 ,    7 ,    1 ,      2.6),
   (10 ,   10 ,    1 ,      2.6),
   ( 7 ,    6 ,    1 ,      3.6),
   ( 9 ,    9 ,    1 ,      3.6),
  ( 11 ,   11 ,    1 ,      3.6),
  ( 13 ,   14 ,    1 ,      3.6),
  (  4 ,   16 ,    1 ,      4.6),
  ( 12 ,   15 ,    1 ,      4.6),
  (  3 ,    3 ,    1 ,      5.6)
) AS t (node, edge, cost, agg_cost);

SELECT
    node::BIGINT, cost::FLOAT, agg_cost::FLOAT
INTO test4
FROM
(VALUES
    (  -1 ,    0 ,        0),
    (   1 ,  0.4 ,      0.4),
    (   2 ,  0.6 ,      0.6),
    (   5 ,    1 ,      1.6),
    (   3 ,    1 ,      1.6),
    (   6 ,    1 ,      2.6),
    (   8 ,    1 ,      2.6),
    (  10 ,    1 ,      2.6),
    (   4 ,    1 ,      2.6),
    (   7 ,    1 ,      3.6),
    (   9 ,    1 ,      3.6),
    (  11 ,    1 ,      3.6),
    (  13 ,    1 ,      3.6),
    (  12 ,    1 ,      4.6)
) AS t (node, cost, agg_cost);

CREATE OR REPLACE FUNCTION test_function()
RETURNS SETOF TEXT AS
$BODY$
BEGIN

IF min_version('3.6.0') THEN
---
--- DIRECTED GRAPH
---
-------- right driving side

PREPARE q1 AS
SELECT node, edge, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM pgr_withPointsDD(
    'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
    'SELECT pid, edge_id, fraction, side from pointsOfInterest',
    -1, 6.8, 'r', details := false);

RETURN QUERY
SELECT set_eq('q1',
    $$SELECT node, edge, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM test2$$,
    'Should be aggregating individual costs: right driving side, DIR');


-------- left driving side

PREPARE q2 AS
SELECT node, edge, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM pgr_withPointsDD(
    'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
    'SELECT pid, edge_id, fraction, side from pointsOfInterest',
    -1, 6.8, 'l', details := false)
ORDER BY seq;

RETURN QUERY
SELECT set_eq('q2',
    $$SELECT node, edge, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM test3$$,
    'Should be aggregating individual costs: left driving side, DIR');

---
--- UNDIRECTED GRAPH
---

-- all results on udirected graph are "allegedly" equal

-------- both driving sides

PREPARE q3 AS
SELECT node, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM pgr_withPointsDD(
    'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
    'SELECT pid, edge_id, fraction, side from pointsOfInterest',
    -1, 6.8, 'b', details := false, directed:=false);

RETURN QUERY
SELECT set_eq('q3',
    $$SELECT node, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM test4$$,
    'Should be aggregating individual costs: both driving sides, UNDI');

END IF;



/* TODO remove tests on v4 of the old signatures */
SET client_min_messages TO ERROR;
---
--- DIRECTED GRAPH
---
-------- both driving sides

PREPARE q1_old AS
SELECT node, edge, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM pgr_withPointsDD(
    'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
    'SELECT pid, edge_id, fraction, side from pointsOfInterest',
    -1, 6.8, driving_side := 'b', details := false)
ORDER BY seq;

RETURN QUERY
SELECT set_eq('q1_old',
    $$SELECT node, edge, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM test1$$,
    'Should be aggregating individual costs: both driving sides, DIR');


-------- right driving side

PREPARE q2_old AS
SELECT node, edge, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM pgr_withPointsDD(
    'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
    'SELECT pid, edge_id, fraction, side from pointsOfInterest',
    -1, 6.8, driving_side := 'r', details := false);

RETURN QUERY
SELECT set_eq('q2_old',
    $$SELECT node, edge, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM test2$$,
    'Should be aggregating individual costs: right driving side, DIR');


-------- left driving side

PREPARE q3_old AS
SELECT node, edge, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM pgr_withPointsDD(
    'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
    'SELECT pid, edge_id, fraction, side from pointsOfInterest',
    -1, 6.8, driving_side := 'l', details := false)
ORDER BY seq;

RETURN QUERY
SELECT set_eq('q3_old',
    $$SELECT node, edge, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM test3$$,
    'Should be aggregating individual costs: left driving side, DIR');

---
--- UNDIRECTED GRAPH
---

-------- both driving sides

PREPARE q4_old AS
SELECT node, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM pgr_withPointsDD(
    'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
    'SELECT pid, edge_id, fraction, side from pointsOfInterest',
    -1, 6.8, driving_side := 'b', details := false, directed:=false);

RETURN QUERY
SELECT set_eq('q4_old',
    $$SELECT node, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM test4$$,
    'Should be aggregating individual costs: both driving sides, UNDI');


-------- right driving side

PREPARE q5_old AS
SELECT node, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM pgr_withPointsDD(
    'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
    'SELECT pid, edge_id, fraction, side from pointsOfInterest',
    -1, 6.8, driving_side := 'r', details := false, directed:=false);

RETURN QUERY
SELECT set_eq('q5_old',
    $$SELECT node, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM test4$$,
    'Should be aggregating individual costs: right driving side, UNDI');


-------- left driving side

PREPARE q6_old AS
SELECT node, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM pgr_withPointsDD(
    'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
    'SELECT pid, edge_id, fraction, side from pointsOfInterest',
    -1, 6.8, driving_side := 'l', details := false, directed:=false);


RETURN QUERY
SELECT set_eq('q6_old',
    $$SELECT node, round(cost::numeric, 12) AS cost, round(agg_cost::numeric, 12) AS agg_cost FROM test4$$,
    'Should be aggregating individual costs: left driving side, UNDI');
END;
$BODY$
language plpgsql;

SELECT test_function();
SELECT finish();
ROLLBACK;
